User: You are a senior Node.js engineer responsible for production stability.

You are given a small Node.js repository that simulates a background job runner.
Running `npm start` executes the worker under strict unhandled-rejection behavior
and the process exits due to an Unhandled Promise Rejection.

Your task: FIX the root cause so the process no longer exits unexpectedly.

IMPORTANT:
- This is a FIXING task.
- Keep changes minimal and targeted. Do NOT rewrite the whole project.
- Do NOT add external dependencies.
- Do NOT “fix” by disabling strict mode, removing the failing job, or ignoring errors globally.
- Do NOT solve by adding a global `process.on('unhandledRejection', () => {})` that swallows errors.
- The fix must correctly handle promise rejections at the source.

============================================================
Required Outcome
============================================================

After the fix:

1) `npm start` must NOT crash the process due to unhandled rejections.
2) Failing jobs must be handled in a defined way:
   - captured and logged, and/or
   - returned as an error result, and/or
   - retried with a small backoff (optional)
3) The worker must continue to process other jobs after a failure.
4) `npm test` must pass.

============================================================
Engineering Constraints (strict)
============================================================

- Every async job execution path must be awaited or have a catch attached.
- Do not convert errors into silent no-ops; surface them via logs or returned results.
- Avoid busy loops (if you retry, add a small delay and a max attempts).

============================================================
Regression Tests (must add)
============================================================

Add at least one test that:
- uses the failing job
- runs the worker (or the core processing function) under strict behavior expectations
- asserts that:
  - the worker does not terminate the process
  - the failure is recorded/returned/logged in a verifiable way
  - the worker still processes succeeding jobs

Use Node built-in test runner (`node:test`) and `assert`.

============================================================
Output Requirements
============================================================

- Provide the updated contents of all modified files.
- Include new/updated tests.
- Keep explanations minimal; code readability matters.


GitHub Copilot: Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/src/index.js)

Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/src/jobs.js)

Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/src/queue.js)

Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/src/worker.js)

Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/test/worker.test.js)

Using "Apply Patch"


```

```


Using "Apply Patch"


```

```


Ran terminal command:  cd c:/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max && npm test

Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/src/worker.js)

Read [](file:///c%3A/Users/v-quansenwen/work/bug-related/runtime-error-0121/gpt-5.1-codex-max/test/worker.test.js)

**Changes**
- Added per-job result tracking with try/catch/finally so failed jobs log and decrement concurrency without unhandled rejections in worker.js.
- Added regression test to ensure a failing data job is recorded as rejected while later jobs still succeed in worker.test.js.

Updated files:

worker.js
```javascript
/**
 * Background job worker with concurrent processing
 */
import { jobHandlers } from './jobs.js';

export class Worker {
  constructor(queue, options = {}) {
    this.queue = queue;
    this.concurrency = options.concurrency || 3;
    this.running = false;
    this.activeJobs = 0;
    this.results = [];
  }

  /**
   * Process a single job
   */
  async processJob(job) {
    const handler = jobHandlers[job.type];
    if (!handler) {
      throw new Error(`Unknown job type: ${job.type}`);
    }
    
    console.log(`Processing job: ${job.type} (${job.id})`);
    const result = await handler(job.payload);
    console.log(`Completed job: ${job.type} (${job.id})`);
    return result;
  }

  /**
   * Execute a job and handle concurrency tracking
   */
  async executeJob(job) {
    this.activeJobs++;

    try {
      const result = await this.processJob(job);
      this.results.push({ jobId: job.id, status: 'fulfilled', result });
    } catch (err) {
      console.error(`Job failed: ${job.type} (${job.id})`, err);
      this.results.push({ jobId: job.id, status: 'rejected', error: err });
    } finally {
      this.activeJobs--;
    }
  }

  /**
   * Main worker loop
   */
  async start() {
    this.running = true;
    console.log(`Worker started (concurrency: ${this.concurrency})`);

    while (this.running) {
      // Process jobs up to concurrency limit
      while (this.activeJobs < this.concurrency && !this.queue.isEmpty()) {
        const job = this.queue.dequeue();
        if (job) {
          this.executeJob(job);
        }
      }

      // Check if work is complete
      if (this.queue.isEmpty() && this.activeJobs === 0) {
        console.log('All jobs processed');
        this.running = false;
        break;
      }

      // Brief pause before next iteration
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  }

  stop() {
    this.running = false;
  }
}
```

worker.test.js
```javascript
/**
 * Tests for the job worker
 */
import { test } from 'node:test';
import assert from 'node:assert';
import { JobQueue } from '../src/queue.js';
import { Worker } from '../src/worker.js';

test('Worker processes email jobs successfully', async () => {
  const queue = new JobQueue();
  
  queue.enqueue({
    id: 'test-1',
    type: 'email',
    payload: { recipient: 'test@example.com' }
  });

  const worker = new Worker(queue, { concurrency: 1 });
  await worker.start();

  assert.strictEqual(queue.isEmpty(), true, 'Queue should be empty after processing');
});

test('Worker processes multiple jobs with concurrency', async () => {
  const queue = new JobQueue();
  
  for (let i = 0; i < 5; i++) {
    queue.enqueue({
      id: `test-${i}`,
      type: 'email',
      payload: { recipient: `user${i}@example.com` }
    });
  }

  const worker = new Worker(queue, { concurrency: 3 });
  await worker.start();

  assert.strictEqual(queue.isEmpty(), true, 'All jobs should be processed');
});

test('Worker processes successful data jobs', async () => {
  const queue = new JobQueue();
  
  // Use recordId that won't trigger failure (not divisible by 7)
  queue.enqueue({
    id: 'data-1',
    type: 'dataProcess',
    payload: { recordId: 100 }
  });

  queue.enqueue({
    id: 'data-2',
    type: 'dataProcess',
    payload: { recordId: 102 }
  });

  const worker = new Worker(queue, { concurrency: 2 });
  await worker.start();

  assert.strictEqual(queue.isEmpty(), true, 'Data jobs should be processed');
});

test('Worker handles failing job without exiting and continues processing', async () => {
  const queue = new JobQueue();

  queue.enqueue({
    id: 'fail-1',
    type: 'dataProcess',
    payload: { recordId: 14 }
  });

  queue.enqueue({
    id: 'ok-email',
    type: 'email',
    payload: { recipient: 'ok@example.com' }
  });

  queue.enqueue({
    id: 'ok-data',
    type: 'dataProcess',
    payload: { recordId: 15 }
  });

  const worker = new Worker(queue, { concurrency: 2 });
  await worker.start();

  assert.strictEqual(queue.isEmpty(), true, 'Queue should drain even when a job fails');

  const statusMap = worker.results.reduce((acc, entry) => {
    acc[entry.jobId] = entry.status;
    return acc;
  }, {});

  assert.strictEqual(statusMap['fail-1'], 'rejected', 'Failing job should be recorded as rejected');
  assert.strictEqual(statusMap['ok-email'], 'fulfilled', 'Subsequent jobs should succeed');
  assert.strictEqual(statusMap['ok-data'], 'fulfilled', 'Worker should keep processing after a failure');
});
```

Tests run: `npm test` (pass).

Made changes.